/**
 * @module @iroha2/data-model
 */
/**
 * @packageDocumentation
 *
 * Iroha v2 data model codecs. Primarily contains the code generated by the `@scale-codec/definition-compiler`
 */

import * as datamodel from './datamodel/index'
import * as crypto from '@iroha2/crypto-core'

export { datamodel }
export * from './core'

export class ExtractQueryOutputError extends Error {
  public query: string
  public expectedOutput: string
  public actualOutput: string

  public constructor(query: string, expectedOutput: string, actualOutput: string) {
    // TODO: improve message
    super(
      `Failed to extract output of query "${query}": expected "${expectedOutput}" data type, got "${actualOutput}". This is a bug!`,
    )
  }
}

export function extractQueryOutput<Q extends keyof datamodel.QueryOutputMap>(
  query: Q,
  response: datamodel.QueryResponse,
): datamodel.QueryOutputMap[Q] {
  const outputKind = datamodel.QueryOutputKindMap[query as keyof datamodel.QueryOutputMap]
  if (response.t === 'Iterable' && response.value.batch.t === outputKind)
    return response.value.batch.value as datamodel.QueryOutputMap[Q]
  // TODO throw good error
  throw new Error('unimplemented')
}

export function extractSingularQueryOutput<Q extends keyof datamodel.SingularQueryOutputMap>(
  query: Q,
  response: datamodel.QueryResponse,
): datamodel.SingularQueryOutputMap[Q] {
  const outputKind = datamodel.SingularQueryOutputKindMap[query as keyof datamodel.SingularQueryOutputMap]
  if (response.t === 'Singular' && response.value.t === outputKind)
    return response.value.value as datamodel.SingularQueryOutputMap[Q]
  // TODO throw good error
  throw new Error('unimplemented')
}

/**
 * The one that is used for e.g. {@link datamodel.TransactionEventFilter}
 */
export function transactionHash(tx: datamodel.SignedTransaction): crypto.Hash {
  const bytes = datamodel.SignedTransaction$codec.encode(tx)
  return crypto.Hash.hash(crypto.Bytes.array(bytes))
}

export function signQuery(
  payload: datamodel.QueryRequestWithAuthority,
  privateKey: crypto.PrivateKey,
): datamodel.SignedQuery {
  const payloadBytes = datamodel.QueryRequestWithAuthority$codec.encode(payload)
  const signature = privateKey.sign(crypto.Bytes.array(crypto.Hash.hash(crypto.Bytes.array(payloadBytes)).payload()))
  return {
    t: 'V1',
    value: {
      payload,
      signature: datamodel.Signature$schema.parse(signature),
    },
  }
}

export function signTransaction(
  payload: datamodel.TransactionPayload,
  privateKey: crypto.PrivateKey,
): datamodel.SignedTransaction {
  const payloadBytes = datamodel.TransactionPayload$codec.encode(payload)
  const signature = privateKey.sign(crypto.Bytes.array(crypto.Hash.hash(crypto.Bytes.array(payloadBytes)).payload()))
  return {
    t: 'V1',
    value: {
      payload,
      signature: datamodel.Signature$schema.parse(signature),
    },
  }
}

// TODO test
export function blockHash(header: datamodel.BlockHeader): crypto.Hash {
  const encoded = datamodel.BlockHeader$codec.encode(header)
  return crypto.Hash.hash(crypto.Bytes.array(encoded))
}
